import numpy as np
from numpy import inf

# Given values for the problem (distance matrix)
d = np.array([
    [0, 10, 12, 11, 14],
    [10, 0, 13, 15, 8],
    [12, 13, 0, 9, 14],
    [11, 15, 9, 0, 16],
    [14, 8, 14, 16, 0]
])

iteration = 100
n_ants = 5
n_citys = 5

# Initialization parameters
m = n_ants
n = n_citys
e = 0.5       # evaporation rate
alpha = 1     # pheromone factor
beta = 2      # visibility factor

# Calculating visibility of next city: visibility(i,j) = 1/d(i,j)
visibility = 1 / d
visibility[visibility == inf] = 0

# Initializing pheromone present on paths to the cities
pheromone = 0.1 * np.ones((n, n))  # pheromone matrix for city-to-city paths

# Initializing routes of ants (size: n_ants x (n_citys+1))
# Adding 1 because we want to come back to the source city
route = np.ones((m, n + 1), dtype=int)

for ite in range(iteration):
    route[:, 0] = 1  # all ants start from city 1

    for i in range(m):  # for each ant
        temp_visibility = np.array(visibility)  # copy visibility

        for j in range(n - 1):
            combine_feature = np.zeros(n)
            cur_loc = route[i, j] - 1  # current city (0-indexed)

            # Make visibility of the current city zero to avoid revisiting
            temp_visibility[:, cur_loc] = 0

            # Calculate pheromone feature (pheromone ^ beta)
            p_feature = np.power(pheromone[cur_loc, :], beta)

            # Calculate visibility feature (visibility ^ alpha)
            v_feature = np.power(temp_visibility[cur_loc, :], alpha)

            # Combine pheromone and visibility features
            combine_feature = p_feature * v_feature

            total = np.sum(combine_feature)
            if total == 0:
                probs = np.zeros_like(combine_feature)
            else:
                probs = combine_feature / total  # probability distribution

            cum_prob = np.cumsum(probs)  # cumulative probability
            r = np.random.random_sample()  # random number [0,1)

            # Choose next city with probability > r
            city = np.nonzero(cum_prob > r)[0][0] + 1

            route[i, j + 1] = city

        # Find the last unvisited city to complete the route
        visited = set(route[i, :-2])
        left = list(set(range(1, n + 1)) - visited)[0]
        route[i, -2] = left  # add the last city before returning to start

    route_opt = np.array(route)

    dist_cost = np.zeros((m, 1))
    for i in range(m):
        s = 0
        for j in range(n - 1):
            s += d[route_opt[i, j] - 1, route_opt[i, j + 1] - 1]  # sum distances
        dist_cost[i] = s

    dist_min_loc = np.argmin(dist_cost)
    dist_min_cost = dist_cost[dist_min_loc]
    best_route = route[dist_min_loc, :]

    # Evaporate pheromone
    pheromone = (1 - e) * pheromone

    # Update pheromone based on the ants' tours
    for i in range(m):
        for j in range(n - 1):
            dt = 1 / dist_cost[i]
            city_from = route_opt[i, j] - 1
            city_to = route_opt[i, j + 1] - 1
            pheromone[city_from, city_to] += dt

print('Route of all the ants at the end:')
print(route_opt)
print()
print('Best path:', best_route)
print('Cost of the best path:', int(dist_min_cost[0]) + d[int(best_route[-2]) - 1, 0])
